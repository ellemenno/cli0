#!/usr/bin/env bash

##### utilities

function out() { printf "%s\n" "$*" >&1; } # stdout for output to be consumed by programs; adds a newline add end
function msg() { printf "%b" "$*" >&2; } # stderr for messaging to be read by users; may use color if [ -t 2 ] is true; BYONL (newlines not supplied here)

function log() {
  local -r hue="$1" # e.g. 32m for plain (dim) green, 91m for bold (bright) red
  local -r label="$2" # when not printing color (i.e. not a terminal), label will be added for differentiation
  shift; shift
  local pre="$(basename "$0"):"
  local col_='\033[' _col='\033[0m'
  if [ -t 2 ]; then msg "$col_$hue$pre $*$_col\n" && return 0; else msg "$pre $label $*\n" && return 0; fi
}

function debug() { log '37m' '::' "$*" ; } # dim white
function note()  { log '36m' '--' "$*" ; } # dim cyan
function info()  { log '32m' '---' "$*" ; } # dim green
function warn()  { log '33m' 'warn' "$*" ; } # dim orange
function error() { log '91m' 'error' "$*" ; } # bright red

function exit_on_error() {
  local -r exit_code=$1
  shift
  [[ $exit_code ]] && ((exit_code != 0)) && {
    error "$@"
    exit "$exit_code"
  }
}

#####

SERVICE="not specified"

function usage() {
  local -r pipe="${1:-2}" # default to stderr, but can be overridden with argument $1
  cat >&$pipe << EOM
provides the skeleton of a simple cli

usage:
  $(basename "$0") [<service> | --<option>]

options:
  -h --help   show this usage info
  <service>   say, see, flip

EOM
}

function rando() {
  local -r lo=$1
  local -r hi=$2
  shuf -i "$lo"-"$hi" -n 1
}

function flip() {
  local -r rn=$(rando 0 100)

  if [[ "$rn" -lt 49 ]]; then
    msg "($rn) heads, i lose\n"
    return 1;
  else
    msg "($rn) tails, i win\n"
    return 0;
  fi
}

function say_things() {
  local -r rn=$(rando 0 100)

  debug "this is a debug message"
  note  "this is a note message"
  info  "this is an info message"
  warn  "this is a warn message"
  error "this is an error message"

  return 0
}

function see_things() {
      #   lo   hi
  local f=30 F=90
  local b=40 B=100

  local bfF BfF
  for fn in {0..7};
  do
    msg "$fn";
    for bn in {0..7};
    do
      bfF="\033[$((b+bn))m \033[$((f+fn))mf\033[$((F+fn))mF \033[0m"
      BfF="\033[$((B+bn))m \033[$((f+fn))mf\033[$((F+fn))mF \033[0m"
      msg " $bfF$BfF";
    done
    msg "\n"
  done
}


if [ $# -eq 0 ]; then 
  warn "no service specified"
  msg "\n"
  usage # usage as part of a user message, send to stderr ( &2, default )
  exit 2;
fi

while [ $# -gt 0 ]
do
  opt="$1"

  case $opt in
    -h|--help)
      shift # past option
      usage 1 && exit 0 # usage explicitly requested as output, send to stdout ( &1 )
      ;;

    flip|say|see)
      SERVICE="$opt"
      shift # past value
      ;;

    *)      # unmatched option
      warn "unknown option '$opt'."
      msg "\n"
      exit 1
      ;;
  esac
done

case $SERVICE in
  flip)
    note "preparing to flip.."
    flip
    ;;

  see)
    note "printing basic palette.."
    msg "\n"
    see_things
    ;;

  say)
    note "preparing to speak.."
    msg "\n"
    say_things
    ;;

  *)    # unmatched option
    warn "unknown service '$SERVICE'"
    msg "\n"
    exit 1
    ;;
esac

exit_on_error $? "$SERVICE failed\n"

msg "\n"
info "done."
msg "\n"
exit 0
