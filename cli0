#!/usr/bin/env bash

##### utilities

function out() { printf "%s\n" "$*" >&1; } # stdout for output to be consumed by programs; adds a newline add end
function msg() { printf "%b" "$*" >&2; } # stderr for messaging to be read by users; may use color if [ -t 2 ] is true; BYONL (newlines not supplied here)

function log() {
  local -r hue="$1" # [0,1];[30-37]m ..e.g. 0;32m for plain green, 1;31m for bold red
  local -r label="$2" # when not printing color (to terminal), label will be added for differentiation
  shift; shift
  local -r pre="$(basename "$0"):"
  local -r col_='\033['; local -r _col='\033[0m'
  if [ -t 2 ]; then msg "$col_$hue$pre $*$_col\n" && return 0; else msg "$pre $label $*\n" && return 0; fi
}

function debug() { log '0;37m' '::' "$*" ; } # plain/dark white
function note()  { log '0;36m' '--' "$*" ; } # plain/dark cyan
function info()  { log '0;32m' '---' "$*" ; } # plain/dark green
function warn()  { log '0;33m' 'warn' "$*" ; } # plain/dark orange
function error() { log '1;31m' 'error' "$*" ; } # bold/light red

function exit_on_error() {
  local -r exit_code=$1
  shift
  [[ $exit_code ]] && ((exit_code != 0)) && {
    error "$@"
    exit "$exit_code"
  }
}

#####

SERVICE="not specified"

function usage() {
  local -r pipe="${1:-2}" # default to stderr, but can be overridden with argument $1
  cat >&$pipe << EOM
provides the skeleton of a simple cli

usage:
  $(basename "$0") [<service> | --<option>]

options:
  -h --help   show this usage info
  <service>   see, say, foo, bar, baz

EOM
}

function rando() {
  local -r lo=$1
  local -r hi=$2
  shuf -i "$lo"-"$hi" -n 1
}

function do_thing() {
  local -r svc="$1"
  local -r rn=$(rando 0 100)

  msg "$svc $rn\n"
  if [[ "$rn" -gt 49 ]]; then return 1; else return 0; fi
}

function say_things() {
  local -r rn=$(rando 0 100)

  debug "this is a debug message"
  note "this is a note message"
  info "this is a info message"
  warn "this is a warn message"
  error "this is an error message"

  return 0
}

function see_things() {
      #   lo   hi
  local f=30 F=90
  local b=40 B=100

  local bfF BfF
  for fn in {0..7};
  do
    msg "$fn";
    for bn in {0..7};
    do
      bfF="\033[$((b+bn))m \033[$((f+fn))mf\033[$((F+fn))mF \033[0m"
      BfF="\033[$((B+bn))m \033[$((f+fn))mf\033[$((F+fn))mF \033[0m"
      msg " $bfF$BfF";
    done
    msg "\n"
  done
}


if [ $# -eq 0 ]; then 
  warn "no service specified"
  msg "\n"
  usage # usage as part of a user message, send to stderr ( &2, default )
  exit 2;
fi

while [ $# -gt 0 ]
do
  opt="$1"

  case $opt in
    -h|--help)
      shift # past option
      usage 1 && exit 0 # usage explicitly requested as output, send to stdout ( &1 )
      ;;

    foo|bar|baz|say|see)
      SERVICE="$opt"
      shift # past value
      ;;

    *)      # unmatched option
      warn "unknown option '$opt'."
      msg "\n"
      exit 1
      ;;
  esac
done

case $SERVICE in
  foo)
    note "preparing to foo.."
    do_thing "foo"
    ;;

  bar)
    note "starting to bar.."
    do_thing "bar"
    ;;

  baz)
    note "beginning to baz.."
    do_thing "baz"
    ;;

  see)
    note "printing basic palette.."
    msg "\n"
    see_things
    ;;

  say)
    note "preparing to speak.."
    msg "\n"
    say_things
    ;;

  *)    # unmatched option
    warn "unknown service '$SERVICE'"
    msg "\n"
    exit 1
    ;;
esac

exit_on_error $? "$SERVICE failed\n"

msg "\n"
info "done."
msg "\n"
exit 0
